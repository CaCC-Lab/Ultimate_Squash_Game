<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Ultimate Squash Game - Python/Pyodide WebAssemblyç‰ˆã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã§å‹•ä½œã™ã‚‹è»½é‡(25KB)ã‚²ãƒ¼ãƒ ">
<meta name="keywords" content="squash,game,python,pyodide,webassembly,pygame">
<meta name="author" content="Ultimate Squash Game Team">
<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:title" content="Ultimate Squash Game - WebAssemblyç‰ˆ">
<meta property="og:description" content="ãƒ–ãƒ©ã‚¦ã‚¶ã§å‹•ä½œã™ã‚‹è»½é‡(25KB)ã‚¹ã‚«ãƒƒã‚·ãƒ¥ã‚²ãƒ¼ãƒ ">
<meta property="og:url" content="https://your-domain.com/ultimate-squash">
<!-- Twitter -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ultimate Squash Game">
<meta name="twitter:description" content="ãƒ–ãƒ©ã‚¦ã‚¶ã§å‹•ä½œã™ã‚‹è»½é‡ã‚¹ã‚«ãƒƒã‚·ãƒ¥ã‚²ãƒ¼ãƒ ">
<title>Ultimate Squash Game - WebAssemblyç‰ˆ</title>
<!-- Favicon -->
<link rel="icon" type="image/x-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImJnIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj48c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMDA0Mjc0Ii8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMTYyMTNlIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSJ1cmwoI2JnKSIgcng9IjQiLz48Y2lyY2xlIGN4PSIxNiIgY3k9IjEyIiByPSI0IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9IiM0ZWNkYzQiIHN0cm9rZS13aWR0aD0iMSIvPjxyZWN0IHg9IjEzIiB5PSIyMiIgd2lkdGg9IjYiIGhlaWdodD0iOCIgcng9IjMiIGZpbGw9IiMwMGZmMDAiLz48cGF0aCBkPSJNOCAyMGgxNnYxSDh6IiBmaWxsPSIjY2NjY2NjIiBvcGFjaXR5PSIwLjgiLz48L3N2Zz4=">
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
color: #ffffff;
overflow: hidden;
height: 100vh;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
}
.game-container {
max-width: 800px;
width: 100%;
text-align: center;
position: relative;
}
.header {
margin-bottom: 20px;
opacity: 0;
animation: fadeInUp 1s ease-out 0.5s forwards;
}
.title {
font-size: 2.5rem;
font-weight: bold;
background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 10px;
text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
}
.subtitle {
font-size: 1rem;
color: #b0b0b0;
font-weight: 300;
}
.canvas-wrapper {
position: relative;
display: inline-block;
border-radius: 15px;
overflow: hidden;
box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
opacity: 0;
animation: scaleIn 1s ease-out 1s forwards;
}
#gameCanvas {
background: #000;
display: block;
border: 3px solid #333;
border-radius: 12px;
}
.loading-overlay {
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(0, 0, 0, 0.9);
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
border-radius: 12px;
transition: opacity 0.5s ease-out;
}
.loading-spinner {
width: 50px;
height: 50px;
border: 3px solid #333;
border-top: 3px solid #4ecdc4;
border-radius: 50%;
animation: spin 1s linear infinite;
margin-bottom: 20px;
}
.loading-text {
font-size: 1.2rem;
color: #4ecdc4;
margin-bottom: 10px;
}
.loading-progress {
font-size: 0.9rem;
color: #888;
}
.controls {
margin-top: 20px;
opacity: 0;
animation: fadeInUp 1s ease-out 1.5s forwards;
}
.control-info {
display: flex;
justify-content: center;
gap: 30px;
font-size: 0.9rem;
color: #999;
}
.control-item {
display: flex;
align-items: center;
gap: 8px;
}
.key {
background: #333;
padding: 4px 8px;
border-radius: 4px;
font-family: monospace;
border: 1px solid #555;
}
.performance-info {
position: absolute;
top: 10px;
left: 10px;
font-size: 0.8rem;
color: #666;
background: rgba(0, 0, 0, 0.7);
padding: 8px 12px;
border-radius: 6px;
opacity: 0;
transition: opacity 0.3s ease;
}
.game-container:hover .performance-info {
opacity: 1;
}
.error-modal {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(0, 0, 0, 0.8);
display: none;
align-items: center;
justify-content: center;
z-index: 1000;
}
.error-content {
background: #1a1a2e;
padding: 30px;
border-radius: 12px;
border: 2px solid #ff6b6b;
max-width: 500px;
text-align: center;
}
.error-title {
color: #ff6b6b;
font-size: 1.5rem;
margin-bottom: 15px;
}
.error-message {
color: #ccc;
margin-bottom: 20px;
line-height: 1.5;
}
.error-button {
background: #ff6b6b;
color: white;
border: none;
padding: 10px 20px;
border-radius: 6px;
cursor: pointer;
font-size: 1rem;
transition: background 0.3s ease;
}
.error-button:hover {
background: #ff5252;
}
@keyframes fadeInUp {
from {
opacity: 0;
transform: translateY(30px);
}
to {
opacity: 1;
transform: translateY(0);
}
}
@keyframes scaleIn {
from {
opacity: 0;
transform: scale(0.9);
}
to {
opacity: 1;
transform: scale(1);
}
}
@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}
@media (max-width: 768px) {
.title {
font-size: 2rem;
}
.control-info {
flex-direction: column;
gap: 10px;
}
#gameCanvas {
width: 90vw;
height: auto;
}
}
/* ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒã‚µãƒãƒ¼ãƒˆ */
@media (prefers-color-scheme: dark) {
body {
background: linear-gradient(135deg, #000000 0%, #1a1a2e 50%, #16213e 100%);
}
}
</style>
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjogIlVsdGltYXRlIFNxdWFzaCBHYW1lIiwgInNob3J0X25hbWUiOiAiU3F1YXNoIiwgImRlc2NyaXB0aW9uIjogIui9u+mHj+e6p1B5dGhvbi9XZWJBc3NlbWJseSDjgrnjgqvjg4Pjgrfjg6XjgrLjg7zjg6AiLCAic3RhcnRfdXJsIjogIi4vIiwgImRpc3BsYXkiOiAiZnVsbHNjcmVlbiIsICJvcmllbnRhdGlvbiI6ICJwb3J0cmFpdCIsICJ0aGVtZV9jb2xvciI6ICIjMDA0Mjc0IiwgImJhY2tncm91bmRfY29sb3IiOiAiIzAwMDAwMCIsICJjYXRlZ29yaWVzIjogWyJnYW1lcyIsICJlbnRlcnRhaW5tZW50Il0sICJsYW5nIjogImphIiwgImljb25zIjogW3sic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU56SWlJR2hsYVdkb2REMGlOeklpSUhacFpYZENiM2c5SWpBZ01DQTNNaUEzTWlJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BHUmxabk0rQ2p4c2FXNWxZWEpIY21Ga2FXVnVkQ0JwWkQwaVltZEhjbUZrSWlCNE1UMGlNQ1VpSUhreFBTSXdKU0lnZURJOUlqRXdNQ1VpSUhreVBTSXhNREFsSWo0S1BITjBiM0FnYjJabWMyVjBQU0l3SlNJZ2MzUjViR1U5SW5OMGIzQXRZMjlzYjNJNkl6QXdOREkzTkNJdlBnbzhjM1J2Y0NCdlptWnpaWFE5SWpFd01DVWlJSE4wZVd4bFBTSnpkRzl3TFdOdmJHOXlPaU14TmpJeE0yVWlMejRLUEM5c2FXNWxZWEpIY21Ga2FXVnVkRDRLUEM5a1pXWnpQZ284Y21WamRDQjNhV1IwYUQwaU56SWlJR2hsYVdkb2REMGlOeklpSUdacGJHdzlJblZ5YkNnalltZEhjbUZrS1NJZ2NuZzlJalFpTHo0S1BHTnBjbU5zWlNCamVEMGlNellpSUdONVBTSXlOeUlnY2owaU9TSWdabWxzYkQwaUkyWm1abVptWmlJdlBnbzhjbVZqZENCNFBTSXlOeUlnZVQwaU5UUWlJSGRwWkhSb1BTSXhPQ0lnYUdWcFoyaDBQU0kwSWlCeWVEMGlNaUlnWm1sc2JEMGlJekF3Wm1Zd01DSXZQZ284TDNOMlp6ND0iLCAic2l6ZXMiOiAiNzJ4NzIiLCAidHlwZSI6ICJpbWFnZS9zdmcreG1sIn0sIHsic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1Ua3lJaUJvWldsbmFIUTlJakU1TWlJZ2RtbGxkMEp2ZUQwaU1DQXdJREU1TWlBeE9USWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStDanhrWldaelBnbzhiR2x1WldGeVIzSmhaR2xsYm5RZ2FXUTlJbUpuUjNKaFpDSWdlREU5SWpBbElpQjVNVDBpTUNVaUlIZ3lQU0l4TURBbElpQjVNajBpTVRBd0pTSStDanh6ZEc5d0lHOW1abk5sZEQwaU1DVWlJSE4wZVd4bFBTSnpkRzl3TFdOdmJHOXlPaU13TURReU56UWlMejRLUEhOMGIzQWdiMlptYzJWMFBTSXhNREFsSWlCemRIbHNaVDBpYzNSdmNDMWpiMnh2Y2pvak1UWXlNVE5sSWk4K0Nqd3ZiR2x1WldGeVIzSmhaR2xsYm5RK0Nqd3ZaR1ZtY3o0S1BISmxZM1FnZDJsa2RHZzlJakU1TWlJZ2FHVnBaMmgwUFNJeE9USWlJR1pwYkd3OUluVnliQ2dqWW1kSGNtRmtLU0lnY25nOUlqRXlJaTgrQ2p4amFYSmpiR1VnWTNnOUlqazJJaUJqZVQwaU56SWlJSEk5SWpJMElpQm1hV3hzUFNJalptWm1abVptSWk4K0NqeHlaV04wSUhnOUlqY3lJaUI1UFNJeE5EUWlJSGRwWkhSb1BTSTBPQ0lnYUdWcFoyaDBQU0l4TWlJZ2NuZzlJallpSUdacGJHdzlJaU13TUdabU1EQWlMejRLUEM5emRtYysiLCAic2l6ZXMiOiAiMTkyeDE5MiIsICJ0eXBlIjogImltYWdlL3N2Zyt4bWwifSwgeyJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTlRFeUlpQm9aV2xuYUhROUlqVXhNaUlnZG1sbGQwSnZlRDBpTUNBd0lEVXhNaUExTVRJaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK0NqeGtaV1p6UGdvOGJHbHVaV0Z5UjNKaFpHbGxiblFnYVdROUltSm5SM0poWkNJZ2VERTlJakFsSWlCNU1UMGlNQ1VpSUhneVBTSXhNREFsSWlCNU1qMGlNVEF3SlNJK0NqeHpkRzl3SUc5bVpuTmxkRDBpTUNVaUlITjBlV3hsUFNKemRHOXdMV052Ykc5eU9pTXdNRFF5TnpRaUx6NEtQSE4wYjNBZ2IyWm1jMlYwUFNJeE1EQWxJaUJ6ZEhsc1pUMGljM1J2Y0MxamIyeHZjam9qTVRZeU1UTmxJaTgrQ2p3dmJHbHVaV0Z5UjNKaFpHbGxiblErQ2p3dlpHVm1jejRLUEhKbFkzUWdkMmxrZEdnOUlqVXhNaUlnYUdWcFoyaDBQU0kxTVRJaUlHWnBiR3c5SW5WeWJDZ2pZbWRIY21Ga0tTSWdjbmc5SWpNeUlpOCtDanhqYVhKamJHVWdZM2c5SWpJMU5pSWdZM2s5SWpFNU1pSWdjajBpTmpRaUlHWnBiR3c5SWlObVptWm1abVlpTHo0S1BISmxZM1FnZUQwaU1Ua3lJaUI1UFNJek9EUWlJSGRwWkhSb1BTSXhNamdpSUdobGFXZG9kRDBpTXpJaUlISjRQU0l4TmlJZ1ptbHNiRDBpSXpBd1ptWXdNQ0l2UGdvOEwzTjJaejQ9IiwgInNpemVzIjogIjUxMng1MTIiLCAidHlwZSI6ICJpbWFnZS9zdmcreG1sIn1dfQ==">
</head>
<body>
<div class="game-container">
<header class="header">
<h1 class="title">Ultimate Squash Game</h1>
<p class="subtitle">Python/Pyodide WebAssemblyç‰ˆ - è»½é‡25KB</p>
</header>
<div class="canvas-wrapper">
<canvas id="gameCanvas" width="640" height="480"></canvas>
<div class="loading-overlay" id="loadingOverlay">
<div class="loading-spinner"></div>
<div class="loading-text">ã‚²ãƒ¼ãƒ èª­ã¿è¾¼ã¿ä¸­...</div>
<div class="loading-progress" id="loadingProgress">Pyodideã‚’åˆæœŸåŒ–ä¸­...</div>
</div>
<div class="performance-info" id="performanceInfo">
FPS: <span id="fpsCounter">60</span> |
Memory: <span id="memoryUsage">1.2MB</span>
</div>
</div>
<div class="controls">
<div class="control-info">
<div class="control-item">
<span class="key">â†</span><span class="key">â†’</span>
<span>ãƒ©ã‚±ãƒƒãƒˆç§»å‹•</span>
</div>
<div class="control-item">
<span class="key">Space</span>
<span>ãƒãƒ¼ã‚º/å†é–‹</span>
</div>
<div class="control-item">
<span class="key">R</span>
<span>ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</span>
</div>
</div>
</div>
</div>
<!-- ã‚¨ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="error-modal" id="errorModal">
<div class="error-content">
<h2 class="error-title">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</h2>
<p class="error-message" id="errorMessage">
ã‚²ãƒ¼ãƒ ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚
</p>
<button class="error-button" onclick="closeErrorModal()">å†è©¦è¡Œ</button>
</div>
</div>
<!-- Pyodideèª­ã¿è¾¼ã¿ -->
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
<script>
let pyodide = null;
let gameLoopId = null;
let gameState = null;
let canvas = null;
let ctx = null;
let performanceMonitor = null;
class PerformanceMonitor {
constructor() {
this.frameCount = 0;
this.lastTime = performance.now();
this.fps = 60;
this.memoryUsage = 0;
this.optimizationStats = null;
}
update() {
this.frameCount++;
const currentTime = performance.now();
if (currentTime - this.lastTime >= 1000) {
this.fps = Math.round(this.frameCount * 1000 / (currentTime - this.lastTime));
this.frameCount = 0;
this.lastTime = currentTime;
if (performance.memory) {
this.memoryUsage = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
}
this.updateDisplay();
}
}
updateOptimizationStats(stats) {
if (stats) {
this.optimizationStats = stats;
// Immediately update display to show optimization stats
this.updateDisplay();
}
}

updateDisplay() {
// Optimize DOM updates - cache elements and update only text content
if (!this._cachedElements) {
const perfInfo = document.getElementById('performanceInfo');
if (perfInfo && !perfInfo.querySelector('#perf-fps')) {
perfInfo.innerHTML =
'FPS: <span id="perf-fps">0</span> | Memory: <span id="perf-memory">0</span>MB' +
'<span id="perf-skipped"></span><span id="perf-reuse"></span>';
}
this._cachedElements = {
perfInfo: perfInfo,
perfFps: document.getElementById('perf-fps'),
perfMemory: document.getElementById('perf-memory'),
perfSkipped: document.getElementById('perf-skipped'),
perfReuse: document.getElementById('perf-reuse')
};
}

// Update performance info with individual span updates
if (this._cachedElements.perfFps) {
this._cachedElements.perfFps.textContent = this.fps;
this._cachedElements.perfMemory.textContent = this.memoryUsage + 'MB';
}

// Display optimization stats if available
if (this.optimizationStats && this._cachedElements.perfSkipped) {
const skipRate = this.optimizationStats.skipped_updates || 0;
const reuseRate = this.optimizationStats.reuse_rate || 0;

this._cachedElements.perfSkipped.textContent = skipRate > 0 ? ` | Skipped: ${skipRate}%` : '';
this._cachedElements.perfReuse.textContent = reuseRate > 0 ? ` | Reuse: ${reuseRate.toFixed(1)}%` : '';
}
}
}
function showError(message, details = '') {
console.error('Game Error:', message, details);
document.getElementById('errorMessage').textContent = message;
document.getElementById('errorModal').style.display = 'flex';
}
function closeErrorModal() {
document.getElementById('errorModal').style.display = 'none';
initializeGame();
}
function updateLoadingProgress(text) {
document.getElementById('loadingProgress').textContent = text;
}
function hideLoading() {
const overlay = document.getElementById('loadingOverlay');
overlay.style.opacity = '0';
setTimeout(() => {
overlay.style.display = 'none';
}, 500);
}
async function initializeGame() {
try {
updateLoadingProgress('Pyodideã‚’åˆæœŸåŒ–ä¸­...');
pyodide = await loadPyodide({
indexURL: "https://cdn.jsdelivr.net/pyodide/v0.26.4/full/"
});
updateLoadingProgress('Pygame-CEã‚’èª­ã¿è¾¼ã¿ä¸­...');
await pyodide.loadPackage(["pygame-ce"]);
updateLoadingProgress('ã‚²ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ä¸­...');
await loadGameCode();
updateLoadingProgress('ã‚²ãƒ¼ãƒ ã‚’åˆæœŸåŒ–ä¸­...');
canvas = document.getElementById('gameCanvas');

// Safe canvas context creation with feature detection
try {
    // Try with all optimization options first
    ctx = canvas.getContext('2d', {
        alpha: false, // Disable transparency for better performance
        desynchronized: true, // Reduce latency - EXPERIMENTAL
        willReadFrequently: false // We're not reading pixels - EXPERIMENTAL
    });
} catch (e) {
    console.warn('Failed to create canvas context with experimental options, trying fallback...', e);
    try {
        // Fallback to just alpha option (widely supported)
        ctx = canvas.getContext('2d', {
            alpha: false
        });
    } catch (e2) {
        console.warn('Failed to create canvas context with alpha option, using default...', e2);
        // Final fallback - basic context
        ctx = canvas.getContext('2d');
    }
}

// Set performance-oriented rendering settings (with feature detection)
if (ctx.imageSmoothingEnabled !== undefined) {
    ctx.imageSmoothingEnabled = false; // Disable antialiasing for pixel-perfect rendering
}

performanceMonitor = new PerformanceMonitor();
await initializeGameState();
updateLoadingProgress('ã‚²ãƒ¼ãƒ é–‹å§‹æº–å‚™å®Œäº†');
hideLoading();
startGameLoop();
console.log('ğŸ® Ultimate Squash Game loaded successfully!');
} catch (error) {
showError(
'ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ãŒæœ€æ–°ç‰ˆã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
error.message
);
}
}
async function loadGameCode() {
const gameModules = {
'model.pygame_game_state': `import time
from typing import List, Dict, Optional, Callable
from dataclasses import dataclass
import math

class PygameBall:
    def __init__(self, x: float = 320, y: float = 240, dx: float = 200, dy: float = 200,
                 radius: float = 10, color: tuple = (255, 255, 255)):
        self.x = float(x)
        self.y = float(y)
        self.dx = float(dx)
        self.dy = float(dy)
        self.radius = float(radius)
        self.color = color
        self.trail = []
        self.max_trail_length = 10

class PygameRacket:
    def __init__(self, x: float = 295, y: float = 450, size: float = 50,
                 height: float = 10, color: tuple = (0, 255, 0)):
        self.x = float(x)
        self.y = float(y)
        self.size = float(size)
        self.height = float(height)
        self.color = color
        self.speed = 300
        self.left_bound = 0
        self.right_bound = 640

class PygameScore:
    def __init__(self):
        self.player_score = 0
        self.level = 1
        self.hits = 0
        self.misses = 0
        self.start_time = time.time()

class PygameGameStateObserver:
    def on_game_state_changed(self, game_state: 'PygameGameState'):
        pass

class PygameGameState:
    def __init__(self):
        self.balls = [PygameBall()]
        self.racket = PygameRacket()
        self.score = PygameScore()
        self.is_paused = False
        self.is_gameover = False
        self.observers = []
        self.canvas_width = 640
        self.canvas_height = 480
    
    def add_observer(self, observer: PygameGameStateObserver):
        self.observers.append(observer)
    
    def notify_observers(self):
        for observer in self.observers:
            observer.on_game_state_changed(self)
    
    def update_ball_position(self, ball: PygameBall, dt: float = 0.016):
        ball.x += ball.dx * dt
        ball.y += ball.dy * dt
        
        if ball.x <= ball.radius or ball.x >= self.canvas_width - ball.radius:
            ball.dx = -ball.dx
        if ball.y <= ball.radius:
            ball.dy = -ball.dy
        if ball.y >= self.canvas_height - ball.radius:
            self.is_gameover = True
        
        if (ball.y + ball.radius >= self.racket.y and 
            ball.x >= self.racket.x and ball.x <= self.racket.x + self.racket.size):
            ball.dy = -abs(ball.dy)
            self.score.hits += 1
        
        self.notify_observers()
    
    def update_racket_position(self, x: float):
        self.racket.x = max(0, min(x, self.canvas_width - self.racket.size))
        self.notify_observers()`,
'view.optimized_web_game_view': `import json
from typing import Dict, List
from model.pygame_game_state import PygameGameState, PygameGameStateObserver

class OptimizedWebCanvasView(PygameGameStateObserver):
    def __init__(self, canvas_id: str = "gameCanvas"):
        self.canvas_id = canvas_id
        self.canvas_width = 640
        self.canvas_height = 480
        self.frame_data = {}
        
    def on_game_state_changed(self, game_state: PygameGameState):
        self.frame_data = self._convert_to_canvas_data(game_state)
    
    def _convert_to_canvas_data(self, game_state: PygameGameState) -> Dict:
        draw_commands = []
        
        draw_commands.append({
            'type': 'fillRect',
            'x': 0, 'y': 0,
            'width': self.canvas_width,
            'height': self.canvas_height,
            'color': '#000000'
        })
        
        for ball in game_state.balls:
            draw_commands.append({
                'type': 'fillCircle',
                'x': ball.x, 'y': ball.y,
                'radius': ball.radius,
                'color': f'rgb{ball.color}'
            })
        
        if game_state.racket:
            draw_commands.append({
                'type': 'fillRect',
                'x': game_state.racket.x,
                'y': game_state.racket.y,
                'width': game_state.racket.size,
                'height': game_state.racket.height,
                'color': f'rgb{game_state.racket.color}'
            })
        
        draw_commands.append({
            'type': 'fillText',
            'text': f'Score: {game_state.score.player_score} | Level: {game_state.score.level}',
            'x': 10, 'y': 30,
            'color': 'white',
            'font': '20px Arial'
        })
        
        return {
            'canvas_id': self.canvas_id,
            'draw_commands': draw_commands,
            'game_state': {
                'paused': game_state.is_paused,
                'gameover': game_state.is_gameover
            }
        }
    
    def get_javascript_interface_data(self) -> str:
        return json.dumps(self.frame_data, ensure_ascii=False)`
};
for (const [moduleName, moduleCode] of Object.entries(gameModules)) {
pyodide.runPython(moduleCode);
}
}
async function initializeGameState() {
pyodide.runPython(`
from model.pygame_game_state import PygameGameState
from view.optimized_web_game_view import OptimizedWebCanvasView

game_state = PygameGameState()
game_view = OptimizedWebCanvasView()
game_state.add_observer(game_view)

def update_game(dt=0.016):
    if not game_state.is_paused and not game_state.is_gameover:
        for ball in game_state.balls:
            game_state.update_ball_position(ball, dt)
    return game_view.get_javascript_interface_data()

def handle_key_input(key):
    if key == 'ArrowLeft' and game_state.racket.x > 0:
        game_state.update_racket_position(game_state.racket.x - 20)
    elif key == 'ArrowRight' and game_state.racket.x < 590:
        game_state.update_racket_position(game_state.racket.x + 20)
    elif key == ' ':
        game_state.is_paused = not game_state.is_paused
    elif key == 'r' or key == 'R':
        restart_game()

def restart_game():
    global game_state
    game_state = PygameGameState()
    game_state.add_observer(game_view)
`);
}
// Optimized drawing function that handles differential rendering
const drawState = {
    lastFrameData: null,
    staticLayer: null,
    dynamicLayer: null,
    currentLayer: 'dynamic',
    dirtyRegions: [],
    skipFrame: false
};

function drawFrame(frameData) {
    try {
        const data = JSON.parse(frameData);
        const commands = data.draw_commands || [];
        const perfStats = data.optimization_stats || {};
        
        // Update performance monitor with optimization stats
        if (performanceMonitor && perfStats) {
            performanceMonitor.updateOptimizationStats(perfStats);
        }
        
        // Process commands with optimization support
        for (const cmd of commands) {
            switch (cmd.command || cmd.type) {
                case 'skip_frame':
                    // Frame skipped due to no changes
                    drawState.skipFrame = true;
                    return;
                    
                case 'set_mode':
                    if (cmd.mode === 'differential') {
                        drawState.dirtyRegions = cmd.regions || [];
                        // Clear only dirty regions
                        for (const region of drawState.dirtyRegions) {
                            ctx.clearRect(region[0], region[1], region[2], region[3]);
                        }
                    }
                    break;
                    
                case 'set_layer':
                    drawState.currentLayer = cmd.layer;
                    break;
                    
                case 'clear':
                    ctx.fillStyle = cmd.color || 'rgb(240, 240, 240)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    break;
                    
                case 'draw_grid':
                    drawGrid(cmd.spacing, cmd.color);
                    break;
                    
                case 'draw_ui_background':
                    ctx.fillStyle = cmd.color;
                    ctx.fillRect(cmd.x, cmd.y, cmd.width, cmd.height);
                    break;
                    
                case 'draw_batch_circles':
                    // Batch draw circles for performance
                    ctx.save();
                    for (const circle of cmd.circles) {
                        ctx.fillStyle = circle.color;
                        ctx.beginPath();
                        ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    ctx.restore();
                    break;
                    
                case 'draw_rectangle':
                    ctx.fillStyle = cmd.color;
                    ctx.fillRect(cmd.x, cmd.y, cmd.width, cmd.height);
                    break;
                    
                case 'update_text':
                    ctx.save();
                    ctx.fillStyle = cmd.color;
                    ctx.font = cmd.font;
                    ctx.fillText(cmd.text, cmd.x, cmd.y);
                    ctx.restore();
                    break;
                    
                case 'draw_overlay':
                    // Draw overlay with background
                    ctx.save();
                    ctx.fillStyle = cmd.backgroundColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = cmd.textColor;
                    ctx.font = cmd.font;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(cmd.text, cmd.x, cmd.y);
                    ctx.restore();
                    break;
                    
                // Legacy command support
                case 'fillRect':
                    ctx.fillStyle = cmd.color;
                    ctx.fillRect(cmd.x, cmd.y, cmd.width, cmd.height);
                    break;
                    
                case 'fillCircle':
                    ctx.fillStyle = cmd.color;
                    ctx.beginPath();
                    ctx.arc(cmd.x, cmd.y, cmd.radius, 0, 2 * Math.PI);
                    ctx.fill();
                    break;
                    
                case 'fillText':
                    ctx.fillStyle = cmd.color;
                    ctx.font = cmd.font;
                    ctx.fillText(cmd.text, cmd.x, cmd.y);
                    break;
            }
        }
        
        drawState.lastFrameData = data;
        drawState.skipFrame = false;
        
    } catch (error) {
        console.error('Draw error:', error);
        // Fallback to simple clear on error
        ctx.fillStyle = 'rgb(240, 240, 240)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
}

// Cache for grid drawing
let gridCache = null;
let gridCacheSpacing = 0;
let gridCacheColor = '';

function drawGrid(spacing, color) {
    // Validate spacing to prevent infinite loops
    if (!Number.isFinite(spacing) || spacing <= 0) {
        return; // guard against bad input
    }
    
    // Check if we need to update the cache
    if (!gridCache || gridCacheSpacing !== spacing || gridCacheColor !== color || 
        gridCache.width !== canvas.width || gridCache.height !== canvas.height) {
        
        // Create or resize off-screen canvas
        if (!gridCache) {
            gridCache = document.createElement('canvas');
        }
        gridCache.width = canvas.width;
        gridCache.height = canvas.height;
        gridCacheSpacing = spacing;
        gridCacheColor = color;
        
        // Draw grid to off-screen canvas
        const cacheCtx = gridCache.getContext('2d', { alpha: true });
        cacheCtx.clearRect(0, 0, gridCache.width, gridCache.height);
        cacheCtx.save();
        cacheCtx.strokeStyle = color;
        cacheCtx.lineWidth = 0.5;
        
        // Vertical lines
        for (let x = 0; x <= gridCache.width; x += spacing) {
            cacheCtx.beginPath();
            cacheCtx.moveTo(x, 0);
            cacheCtx.lineTo(x, gridCache.height);
            cacheCtx.stroke();
        }
        
        // Horizontal lines
        for (let y = 0; y <= gridCache.height; y += spacing) {
            cacheCtx.beginPath();
            cacheCtx.moveTo(0, y);
            cacheCtx.lineTo(gridCache.width, y);
            cacheCtx.stroke();
        }
        
        cacheCtx.restore();
    }
    
    // Draw cached grid to main canvas
    ctx.drawImage(gridCache, 0, 0);
}
// Performance-optimized game loop
let lastFrameTime = 0;
const targetFPS = 60;
const frameInterval = 1000 / targetFPS;
let accumulator = 0;

function gameLoop(currentTime) {
    try {
        // Reset skipFrame flag at the start of each frame
        drawState.skipFrame = false;
        
        // Frame rate limiting
        const deltaTime = currentTime - lastFrameTime;
        lastFrameTime = currentTime;
        
        // Skip frames if running too fast
        if (deltaTime < frameInterval * 0.75) {
            gameLoopId = requestAnimationFrame(gameLoop);
            return;
        }
        
        // Update game state and get optimized draw commands
        const frameData = pyodide.runPython('update_game()');
        
        // Only draw if we have valid frame data
        if (frameData && !drawState.skipFrame) {
            drawFrame(frameData);
        }
        
        // Update performance monitoring less frequently
        accumulator += deltaTime;
        if (accumulator >= 100) { // Update every 100ms instead of every frame
            performanceMonitor.update();
            accumulator = 0;
        }
    } catch (error) {
        console.error('Game loop error:', error);
    }
    
    gameLoopId = requestAnimationFrame(gameLoop);
}
function startGameLoop() {
if (gameLoopId) {
cancelAnimationFrame(gameLoopId);
}
gameLoopId = requestAnimationFrame(gameLoop);
}
document.addEventListener('keydown', function(event) {
if (pyodide) {
try {
pyodide.runPython(`handle_key_input('${event.key}')`);
} catch (error) {
console.error('Key input error:', error);
}
}
});
// Visibility change handler moved above for better performance management
window.addEventListener('error', function(event) {
showError('äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', event.error?.message || '');
});
window.addEventListener('unhandledrejection', function(event) {
showError('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', event.reason);
});

// Handle window resize to clear grid cache
window.addEventListener('resize', function() {
    // Clear grid cache on resize to force redraw with new dimensions
    gridCache = null;
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
    }
    if (pyodide) {
        try {
            pyodide.runPython('game_state = None\ngame_view = None');
        } catch (e) {}
    }
    // Clean up off-screen canvases
    if (gridCache) {
        gridCache = null;
    }
});

// Handle page visibility changes for better performance
let wasRunning = false;
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        if (gameLoopId) {
            wasRunning = true;
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
        }
        if (pyodide) {
            pyodide.runPython('game_state.is_paused = True');
        }
    } else if (wasRunning) {
        wasRunning = false;
        if (pyodide) {
            pyodide.runPython('game_state.is_paused = False');
            startGameLoop();
        }
    }
});
// Audio handling function (currently not used)
function handleGameAudio(gameState) {
if (window.gameAudio && gameState) {
if (gameState.includes('hits') && Math.random() < 0.3) {
window.gameAudio.playPaddleHit();
}
if (gameState.includes('ball.dx = -ball.dx') || gameState.includes('ball.dy = -ball.dy')) {
window.gameAudio.playWallBounce();
}
if (gameState.includes('gameover') || gameState.includes('is_gameover = True')) {
window.gameAudio.playGameOver();
}
}
}
initializeGame();
class GameAudioEngine {
constructor() {
this.audioContext = null;
this.sounds = {
"paddle_hit": {
"type": "beep",
"frequency": 440,
"duration": 0.1,
"volume": 0.3
},
"wall_bounce": {
"type": "beep",
"frequency": 220,
"duration": 0.08,
"volume": 0.2
},
"game_over": {
"type": "sweep",
"start_freq": 440,
"end_freq": 110,
"duration": 0.5,
"volume": 0.4
},
"score_up": {
"type": "chord",
"frequencies": [440, 554, 659],
"duration": 0.3,
"volume": 0.3
}
};
this.enabled = true;
this.initAudio();
}
initAudio() {
try {
this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
} catch (e) {
console.warn('Web Audio API not supported');
this.enabled = false;
}
}
async playSound(soundName) {
if (!this.enabled || !this.audioContext) return;
if (this.audioContext.state === 'suspended') {
await this.audioContext.resume();
}
const soundDef = this.sounds[soundName];
if (!soundDef) return;
const oscillator = this.audioContext.createOscillator();
const gainNode = this.audioContext.createGain();
oscillator.connect(gainNode);
gainNode.connect(this.audioContext.destination);
const now = this.audioContext.currentTime;
switch(soundDef.type) {
case 'beep':
oscillator.frequency.setValueAtTime(soundDef.frequency, now);
break;
case 'sweep':
oscillator.frequency.setValueAtTime(soundDef.start_freq, now);
oscillator.frequency.exponentialRampToValueAtTime(soundDef.end_freq, now + soundDef.duration);
break;
case 'chord':
oscillator.frequency.setValueAtTime(soundDef.frequencies[0], now);
break;
}
gainNode.gain.setValueAtTime(soundDef.volume, now);
gainNode.gain.exponentialRampToValueAtTime(0.01, now + soundDef.duration);
oscillator.start(now);
oscillator.stop(now + soundDef.duration);
}
playPaddleHit() { this.playSound('paddle_hit'); }
playWallBounce() { this.playSound('wall_bounce'); }
playGameOver() { this.playSound('game_over'); }
playScoreUp() { this.playSound('score_up'); }
}
window.gameAudio = new GameAudioEngine();
document.addEventListener('click', () => {
if (window.gameAudio && window.gameAudio.audioContext) {
window.gameAudio.audioContext.resume();
}
}, { once: true });
</script>
</body>
</html>